"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var ts = require("typescript");
var fs_module_methods_arguments_info_1 = require("../fs-module-methods-arguments-info");
var node_kind_1 = require("../node-kind");
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new RuleWalker(sourceFile, this.getOptions()));
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var expressionsToCheck = ['fs', "require('fs')", 'require("fs")', 'require(`fs`)'];
var reservedIdentifiers = ['__dirname'];
var RuleWalker = (function (_super) {
    tslib_1.__extends(RuleWalker, _super);
    function RuleWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RuleWalker.prototype.visitPropertyAccessExpression = function (node) {
        var name = node.name, expression = node.expression;
        if (name && node.parent && expression) {
            var methodName = name.getText();
            var parent = node.parent;
            var fsArgsInfo = fs_module_methods_arguments_info_1.default.get(methodName);
            var methodArguments_1 = parent.arguments;
            if (fsArgsInfo && methodArguments_1 && expressionsToCheck.includes(expression.getText())) {
                var invalidArgumentIndices = fsArgsInfo.filter(function (index) {
                    var arg = methodArguments_1[index];
                    if (!arg) {
                        return false;
                    }
                    var kind = arg.kind;
                    if (kind === ts.SyntaxKind.BinaryExpression) {
                        var _a = arg, left = _a.left, right = _a.right;
                        if (left &&
                            left.kind === ts.SyntaxKind.Identifier &&
                            reservedIdentifiers.includes(left.getText())) {
                            return Boolean(right && !node_kind_1.stringLiteralKinds.includes(right.kind));
                        }
                        if (right &&
                            right.kind === ts.SyntaxKind.Identifier &&
                            reservedIdentifiers.includes(right.getText())) {
                            return Boolean(left && !node_kind_1.stringLiteralKinds.includes(left.kind));
                        }
                    }
                    if (kind === ts.SyntaxKind.TemplateExpression) {
                        var _b = arg.templateSpans, templateSpans = _b === void 0 ? [] : _b;
                        var firstTemplateSpan = templateSpans[0];
                        var firstTemplateSpanExpr = firstTemplateSpan && firstTemplateSpan.expression;
                        if (firstTemplateSpanExpr &&
                            firstTemplateSpanExpr.kind === ts.SyntaxKind.Identifier &&
                            reservedIdentifiers.includes(firstTemplateSpanExpr.getText()) &&
                            !templateSpans[1]) {
                            return false;
                        }
                    }
                    return !node_kind_1.stringLiteralKinds.includes(kind);
                });
                if (invalidArgumentIndices[0] !== undefined) {
                    var errorIndex = invalidArgumentIndices.join(', ');
                    this.addFailureAtNode(node, "Found fs." + methodName + " with non-literal argument at index " + errorIndex);
                }
            }
        }
        _super.prototype.visitPropertyAccessExpression.call(this, node);
    };
    return RuleWalker;
}(Lint.RuleWalker));
