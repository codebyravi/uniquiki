import { BehaviorSubject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * portable shortcut for the RootRoute cases
 * @type {?}
 */
const rootNote = {
    root: { path: '' }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * generator that keeps and generates unique identifiers
 * @return {?}
 */
function* idfy() {
    /** @type {?} */
    let index = 0;
    while (true) {
        /** @type {?} */
        const options = yield index++;
        if (!options) {
            continue;
        }
        index = options.reset ? -1 : index;
    }
}
/**
 * provides ordered ids
 * @type {?}
 */
const indexer = idfy();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prevents to record empty state paths
 * @param {?} state
 * @param {?} path
 * @return {?}
 */
function setNotEmptyPath(state, path) {
    return path !== '' ? [...state, path] : state;
}
/**
 * Checks multi path in a single route
 * @param {?} path
 * @return {?}
 */
function checkMultiPath(path) {
    /** @type {?} */
    const slashId = path ? path.indexOf('/') : -1;
    return slashId !== -1;
}
/**
 * Prevents to record multi path in the state
 * @param {?} path
 * @return {?}
 */
function splitPath(path) {
    return path.split('/').filter((/**
     * @param {?} state
     * @return {?}
     */
    (state) => !!state));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Assigns a value based on the parent's  state and a current path
 * @type {?}
 */
const setState = (/**
 * @param {?} parentSlice
 * @param {?} path
 * @return {?}
 */
(parentSlice, path) => {
    if (path.includes('*')) {
        return [path];
    }
    return parentSlice !== null
        ? setNotEmptyPath(parentSlice.state, path)
        : setNotEmptyPath(['/'], path);
});
/**
 * Absorbs and gives params out together
 * @type {?}
 */
const reduceParams = (/**
 * @param {?} params
 * @param {?} restParams
 * @return {?}
 */
(params, restParams) => restParams.reduce((/**
 * @param {?} accParams
 * @param {?} param
 * @return {?}
 */
(accParams, param) => (Object.assign({}, accParams, param))), params));
/**
 * Replaces property with a value
 * Helps stateFn generating dynamic values
 * @type {?}
 */
const handleState = (/**
 * @param {?} params
 * @param {?=} state
 * @return {?}
 */
(params, state = []) => Object.keys(params).reduce((/**
 * @param {?} accState
 * @param {?} param
 * @return {?}
 */
(accState, param) => accState.map((/**
 * @param {?} slice
 * @return {?}
 */
(slice) => slice === `:${param}` ? params[param] : slice))), state));
/**
 * Supports dynamic paths
 * @param {?} state
 * @param {?=} params
 * @param {...?} otherParams
 * @return {?}
 */
function stateFn(state, params, ...otherParams) {
    if (!params) {
        return state;
    }
    /** @type {?} */
    const parameters = otherParams.length === 0 ? params : reduceParams(params, otherParams);
    return handleState(parameters, state);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Serializes routes
 * to enhance capabilities
 * @template R, C
 * @param {?} parentSlice
 * @param {?} routes
 * @return {?}
 */
function enhance(parentSlice, routes) {
    return Object.keys(routes).reduce((/**
     * @param {?} acc
     * @param {?} routeName
     * @return {?}
     */
    (acc, routeName) => {
        const { children, path, lazy } = routes[routeName];
        /** @type {?} */
        const state = setState(parentSlice, path);
        /** @type {?} */
        const route = {
            id: indexer.next().value,
            parentId: parentSlice !== null ? parentSlice.id : null,
            state,
            stateFn: stateFn.bind(null, state),
            path: checkMultiPath(path) ? splitPath(path) : path,
            lazy: lazy || null,
            routeName
        };
        /* tslint:disable:prefer-object-spread */
        return Object.assign(acc, {
            [routeName]: Object.assign({}, route, { children: children !== undefined ? enhance(route, children) : null })
        });
    }), (/** @type {?} */ ({})));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * refreshes children parent target
 * because of replacing them with a parent node
 * @template R, C
 * @param {?} parent
 * @return {?}
 */
function refreshChildren(parent) {
    /** @type {?} */
    const children = parent.children;
    /** @type {?} */
    const inheritorId = parent.id + 1;
    /** @type {?} */
    const inheritorName = Object.keys(children).find((/**
     * @param {?} routeName
     * @return {?}
     */
    (routeName) => children[routeName].id === inheritorId));
    return Object.keys(children).reduce((/**
     * @param {?} acc
     * @param {?} name
     * @return {?}
     */
    (acc, name) => {
        /** @type {?} */
        const parentId = children[name].id === inheritorId
            ? parent.parentId
            : children[inheritorName].id;
        /** @type {?} */
        const routeName = name === inheritorName && name === 'root' ? parent.routeName : name;
        /** @type {?} */
        const route = Object.assign({}, children[name], { parentId, routeName });
        /* tslint:disable:prefer-object-spread */
        /* https://github.com/Microsoft/TypeScript/issues/10727 */
        return (/** @type {?} */ (Object.assign({}, ((/** @type {?} */ (acc))), { [routeName]: route })));
    }), (/** @type {?} */ ({})));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * stores routes states at the same level
 * @type {?}
 */
const hub = new BehaviorSubject(null);
/**
 * Detects and handles children routes
 * @type {?}
 */
const entitify = (/**
 * @template R, C
 * @param {?} routes
 * @return {?}
 */
(routes) => Object.keys(routes).reduce((/**
 * @param {?} acc
 * @param {?} routeName
 * @return {?}
 */
(acc, routeName) => routes[routeName].children
    ? Object.assign({}, acc, refreshChildren(routes[routeName]))
    : Object.assign({}, acc, { [routeName]: routes[routeName] })), (/** @type {?} */ ({}))));
/**
 * Returns the next hub value
 * @template R, C
 * @param {?} routeName
 * @param {?} routes
 * @return {?}
 */
function nextHubValue(routeName, routes) {
    /** @type {?} */
    const slice = entitify(routes);
    return (/** @type {?} */ (Object.assign({}, hub.value, {
        [routeName]: slice
    })));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates main parent routes
 * Entry point for the hub
 * @template R, C
 * @param {?} routes
 * @param {?=} routeName
 * @return {?}
 */
function createRoot(routes, routeName = 'app') {
    if (hub.value !== null) {
        throw new Error('Routeshub is already declared');
    }
    /** @type {?} */
    const rootSlice = enhance(null, routes);
    /** @type {?} */
    const initialRoutesState = nextHubValue(routeName, rootSlice);
    hub.next(initialRoutesState);
    return hub.value[routeName];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates a feature route
 * @template R, C
 * @param {?} parentRoute
 * @param {?} routes
 * @return {?}
 */
function createFeature(parentRoute, routes) {
    /** @type {?} */
    const feature = enhance(parentRoute, routes);
    /** @type {?} */
    const updatedRouteState = nextHubValue(parentRoute.routeName, feature);
    hub.next(updatedRouteState);
    return hub.value[parentRoute.routeName];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { rootNote, createRoot, createFeature };

//# sourceMappingURL=routeshub.js.map