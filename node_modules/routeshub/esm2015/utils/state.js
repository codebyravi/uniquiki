/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { setNotEmptyPath } from './path';
/**
 * Assigns a value based on the parent's  state and a current path
 * @type {?}
 */
export const setState = (/**
 * @param {?} parentSlice
 * @param {?} path
 * @return {?}
 */
(parentSlice, path) => {
    if (path.includes('*')) {
        return [path];
    }
    return parentSlice !== null
        ? setNotEmptyPath(parentSlice.state, path)
        : setNotEmptyPath(['/'], path);
});
/**
 * Absorbs and gives params out together
 * @type {?}
 */
const reduceParams = (/**
 * @param {?} params
 * @param {?} restParams
 * @return {?}
 */
(params, restParams) => restParams.reduce((/**
 * @param {?} accParams
 * @param {?} param
 * @return {?}
 */
(accParams, param) => (Object.assign({}, accParams, param))), params));
const ɵ0 = reduceParams;
/**
 * Replaces property with a value
 * Helps stateFn generating dynamic values
 * @type {?}
 */
const handleState = (/**
 * @param {?} params
 * @param {?=} state
 * @return {?}
 */
(params, state = []) => Object.keys(params).reduce((/**
 * @param {?} accState
 * @param {?} param
 * @return {?}
 */
(accState, param) => accState.map((/**
 * @param {?} slice
 * @return {?}
 */
(slice) => slice === `:${param}` ? params[param] : slice))), state));
const ɵ1 = handleState;
/**
 * Supports dynamic paths
 * @param {?} state
 * @param {?=} params
 * @param {...?} otherParams
 * @return {?}
 */
export function stateFn(state, params, ...otherParams) {
    if (!params) {
        return state;
    }
    /** @type {?} */
    const parameters = otherParams.length === 0 ? params : reduceParams(params, otherParams);
    return handleState(parameters, state);
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9yb3V0ZXNodWIvIiwic291cmNlcyI6WyJ1dGlscy9zdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7Ozs7QUFLekMsTUFBTSxPQUFPLFFBQVE7Ozs7O0FBQUcsQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUU7SUFDNUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNmO0lBRUQsT0FBTyxXQUFXLEtBQUssSUFBSTtRQUN6QixDQUFDLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDO1FBQzFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUE7Ozs7O01BS0ssWUFBWTs7Ozs7QUFBRyxDQUFDLE1BQWMsRUFBRSxVQUFvQixFQUFVLEVBQUUsQ0FDcEUsVUFBVSxDQUFDLE1BQU07Ozs7O0FBQ2YsQ0FBQyxTQUFpQixFQUFFLEtBQWEsRUFBVSxFQUFFLENBQUMsbUJBQ3pDLFNBQVMsRUFDVCxLQUFLLEVBQ1IsR0FDRixNQUFNLENBQ1AsQ0FBQTs7Ozs7OztNQU1HLFdBQVc7Ozs7O0FBQUcsQ0FBQyxNQUFjLEVBQUUsUUFBa0IsRUFBRSxFQUFZLEVBQUUsQ0FDckUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNOzs7OztBQUN4QixDQUFDLFFBQWtCLEVBQUUsS0FBYSxFQUFZLEVBQUUsQ0FDOUMsUUFBUSxDQUFDLEdBQUc7Ozs7QUFDVixDQUFDLEtBQWEsRUFBVSxFQUFFLENBQ3hCLEtBQUssS0FBSyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFDaEQsR0FDSCxLQUFLLENBQ04sQ0FBQTs7Ozs7Ozs7O0FBS0gsTUFBTSxVQUFVLE9BQU8sQ0FDckIsS0FBSyxFQUNMLE1BQWUsRUFDZixHQUFHLFdBQXFCO0lBRXhCLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDWCxPQUFPLEtBQUssQ0FBQztLQUNkOztVQUVLLFVBQVUsR0FDZCxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQztJQUV2RSxPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDeEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcmFtcyB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgc2V0Tm90RW1wdHlQYXRoIH0gZnJvbSAnLi9wYXRoJztcblxuLyoqXG4gKiBBc3NpZ25zIGEgdmFsdWUgYmFzZWQgb24gdGhlIHBhcmVudCdzICBzdGF0ZSBhbmQgYSBjdXJyZW50IHBhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFN0YXRlID0gKHBhcmVudFNsaWNlLCBwYXRoKSA9PiB7XG4gIGlmIChwYXRoLmluY2x1ZGVzKCcqJykpIHtcbiAgICByZXR1cm4gW3BhdGhdO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudFNsaWNlICE9PSBudWxsXG4gICAgPyBzZXROb3RFbXB0eVBhdGgocGFyZW50U2xpY2Uuc3RhdGUsIHBhdGgpXG4gICAgOiBzZXROb3RFbXB0eVBhdGgoWycvJ10sIHBhdGgpO1xufTtcblxuLyoqXG4gKiBBYnNvcmJzIGFuZCBnaXZlcyBwYXJhbXMgb3V0IHRvZ2V0aGVyXG4gKi9cbmNvbnN0IHJlZHVjZVBhcmFtcyA9IChwYXJhbXM6IFBhcmFtcywgcmVzdFBhcmFtczogUGFyYW1zW10pOiBQYXJhbXMgPT5cbiAgcmVzdFBhcmFtcy5yZWR1Y2UoXG4gICAgKGFjY1BhcmFtczogUGFyYW1zLCBwYXJhbTogUGFyYW1zKTogUGFyYW1zID0+ICh7XG4gICAgICAuLi5hY2NQYXJhbXMsXG4gICAgICAuLi5wYXJhbVxuICAgIH0pLFxuICAgIHBhcmFtc1xuICApO1xuXG4vKipcbiAqIFJlcGxhY2VzIHByb3BlcnR5IHdpdGggYSB2YWx1ZVxuICogSGVscHMgc3RhdGVGbiBnZW5lcmF0aW5nIGR5bmFtaWMgdmFsdWVzXG4gKi9cbmNvbnN0IGhhbmRsZVN0YXRlID0gKHBhcmFtczogUGFyYW1zLCBzdGF0ZTogc3RyaW5nW10gPSBbXSk6IHN0cmluZ1tdID0+XG4gIE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKFxuICAgIChhY2NTdGF0ZTogc3RyaW5nW10sIHBhcmFtOiBzdHJpbmcpOiBzdHJpbmdbXSA9PlxuICAgICAgYWNjU3RhdGUubWFwKFxuICAgICAgICAoc2xpY2U6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgICAgICAgIHNsaWNlID09PSBgOiR7cGFyYW19YCA/IHBhcmFtc1twYXJhbV0gOiBzbGljZVxuICAgICAgKSxcbiAgICBzdGF0ZVxuICApO1xuXG4vKipcbiAqIFN1cHBvcnRzIGR5bmFtaWMgcGF0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlRm4oXG4gIHN0YXRlLFxuICBwYXJhbXM/OiBQYXJhbXMsXG4gIC4uLm90aGVyUGFyYW1zOiBQYXJhbXNbXVxuKTogc3RyaW5nW10ge1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHBhcmFtZXRlcnMgPVxuICAgIG90aGVyUGFyYW1zLmxlbmd0aCA9PT0gMCA/IHBhcmFtcyA6IHJlZHVjZVBhcmFtcyhwYXJhbXMsIG90aGVyUGFyYW1zKTtcblxuICByZXR1cm4gaGFuZGxlU3RhdGUocGFyYW1ldGVycywgc3RhdGUpO1xufVxuIl19